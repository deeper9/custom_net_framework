## 线程

不加锁：多个线程可能读到同一个结果，导致结果异常  
加读锁：只保证多个线程读取正常，写操作不保证，所以多个线程可能读取相同的值  
加写锁：一个线程读取数据后其他线程无法读写  
读写锁的主要目的是提高并发性：当没有线程进行写操作时，多个线程可以同时读取数据，从而提高系统的并发性能。

### 信号量
一种用于进程同步的机制，它是一个具有整型计数器的变量，用于管理多个线程或进程对共享资源的访问
#### 类型
1. 计数信号量（Counting Semaphore）：它允许多个线程访问多个共享资源。计数信号量的计数器表示可用资源的数量。线程可以增加或减少计数器，当计数器为0时，线程必须等待直到有资源释放。
2. 二进制信号量（Binary Semaphore）：也称为互斥量（Mutex），它类似于计数信号量，但计数器值只能是0或1。它用于实现互斥访问，确保在任何时刻只有一个线程可以访问资源。
#### 操作
1. wait（P操作）：减少信号量的计数器。如果计数器值大于0，表示有可用资源，线程继续执行并减少计数器。如果计数器值为0，线程进入等待状态，直到有资源释放。
2. signal（V操作）：增加信号量的计数器。如果有线程在等待资源，唤醒一个等待线程。
#### 使用场景
1. 互斥（Mutex）：信号量可以用来保护临界区，确保只有一个线程能进入临界区。例如，二进制信号量可以实现互斥锁。
2. 资源计数：计数信号量可以用来管理固定数量的资源。例如，限制数据库连接池的最大连接数。
3. 条件同步：信号量可以用于线程之间的条件同步，确保某些操作按照预期顺序执行。例如，一个线程在打印日志前等待另一个线程完成初始化操作。

#### 代码应用
```cpp
Thread::Thread()
{
    pthread_create(&m_thread, nullptr, &Thread::run, this);
    m_semaphore.wait();
}
Thread::run(void* arg)
{
    arg->m_semaphore.notify();
}
```
当前线程执行构造函数时会通过pthread_create创建一个新线程，新线程执行run，参数为this  
外部无法保证Thread()线程和新线程的返回顺序，有可能Thread()线程返回后，新线程没有创建完毕  
在Thread()中wait，run()中arg进行notify保证新线程创建完毕并执行后才返回Thread()，保证外部使用Thread()返回时内部新建线程完毕
```cpp
// 当m_cb内有智能指针时，防止引用被释放掉
std::function<void()> cb;
cb.swap(thread->m_cb);
```

#### 相关api
1. pthread_rwlock_init()：初始化读写锁
2. pthread_rwlock_destroy(): 销毁
3. pthread_rwlock_rdlock(): 获取读锁
4. pthread_rwlock_wrlock(): 获取写锁
5. pthread_rwlock_unlock(): 释放锁
6. mutex.wrlock(): 写锁上锁
7. mutex.rdlock(): 读锁上锁
7. mutex.unlock(): 解锁